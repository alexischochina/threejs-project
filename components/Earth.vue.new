<template>
  <div ref="container" class="earth-container"></div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { Lensflare, LensflareElement } from 'three/examples/jsm/objects/Lensflare.js';

const container = ref<HTMLElement | null>(null);
let scene: THREE.Scene;
let camera: THREE.PerspectiveCamera;
let renderer: THREE.WebGLRenderer;
let earth: THREE.Mesh;
let satellite: THREE.Mesh;
let controls: OrbitControls;
let animationFrameId: number;

function init() {
  if (!container.value) return;

  // Créer la scène
  scene = new THREE.Scene();
  
  // Ajouter un fond d'étoiles amélioré
  const textureLoader = new THREE.TextureLoader();
  
  // Charger les textures de galaxie et de nébuleuse
  const nebulaTexture = textureLoader.load('/textures/space/nebula.jpg');
  const galaxyTexture = textureLoader.load('/textures/space/galaxy.jpg');
  
  // Premier skybox (nébuleuse en arrière-plan)
  const skyboxGeometry = new THREE.SphereGeometry(400, 64, 64);
  skyboxGeometry.scale(-1, 1, 1);
  
  const skyboxMaterial = new THREE.MeshBasicMaterial({
    map: nebulaTexture,
    side: THREE.BackSide,
    fog: false,
  });
  
  const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
  skybox.rotation.x = Math.PI * 0.1;
  skybox.rotation.y = Math.PI * 0.25;
  scene.add(skybox);
  
  // Deuxième skybox (galaxie plus proche, semi-transparent)
  const innerSkyboxGeometry = new THREE.SphereGeometry(250, 64, 64);
  innerSkyboxGeometry.scale(-1, 1, 1);
  
  const innerSkyboxMaterial = new THREE.MeshBasicMaterial({
    map: galaxyTexture,
    side: THREE.BackSide,
    transparent: true,
    opacity: 0.5,
    fog: false,
    blending: THREE.AdditiveBlending,
  });
  
  const innerSkybox = new THREE.Mesh(innerSkyboxGeometry, innerSkyboxMaterial);
  innerSkybox.rotation.x = Math.PI * -0.2;
  innerSkybox.rotation.z = Math.PI * 0.15;
  scene.add(innerSkybox);

  // Ajouter un effet de particules d'étoiles pour renforcer l'immersion
  const starsGeometry = new THREE.BufferGeometry();
  const starsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.7,
    transparent: true,
    opacity: 0.8,
    sizeAttenuation: true
  });

  // Créer 3000 étoiles aléatoires autour de la scène avec des couleurs variées
  const starsVertices = [];
  const starsColors = [];
  
  // Couleurs d'étoiles possibles
  const starColors = [
    new THREE.Color(0xffffff), // blanc
    new THREE.Color(0xffffdd), // blanc chaud
    new THREE.Color(0xddddff), // blanc bleuté
    new THREE.Color(0xffdddd), // blanc rougeâtre
    new THREE.Color(0x9bb0ff), // bleu ciel
    new THREE.Color(0xaabfff), // bleu clair
    new THREE.Color(0xffcc6f), // jaune
  ];
  
  for (let i = 0; i < 3000; i++) {
    // Position aléatoire dans un espace sphérique
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const radius = 150 + Math.random() * 150; // Entre 150 et 300 unités
    
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    
    starsVertices.push(x, y, z);
    
    // Couleur aléatoire parmi les options
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    starsColors.push(color.r, color.g, color.b);
  }

  starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
  starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starsColors, 3));
  
  // Utiliser les couleurs personnalisées
  starsMaterial.vertexColors = true;
  
  const starField = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(starField);
  
  // Créer un second champ d'étoiles plus lointain avec des étoiles plus petites
  const farStarsGeometry = new THREE.BufferGeometry();
  const farStarsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.3,
    transparent: true,
    opacity: 0.6,
    sizeAttenuation: true,
    vertexColors: true
  });
  
  const farStarsVertices = [];
  const farStarsColors = [];
  
  for (let i = 0; i < 5000; i++) {
    // Position aléatoire dans un espace sphérique plus grand
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const radius = 300 + Math.random() * 50; // Entre 300 et 350 unités
    
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    
    farStarsVertices.push(x, y, z);
    
    // Couleur aléatoire parmi les options, légèrement atténuée
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    farStarsColors.push(color.r * 0.8, color.g * 0.8, color.b * 0.8); // Plus atténué
  }
  
  farStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(farStarsVertices, 3));
  farStarsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(farStarsColors, 3));
  
  const farStarField = new THREE.Points(farStarsGeometry, farStarsMaterial);
  scene.add(farStarField);

  // Créer la caméra
  camera = new THREE.PerspectiveCamera(
    75,
    container.value.clientWidth / container.value.clientHeight,
    0.1,
    1000
  );
  camera.position.z = 7;
  camera.position.y = 2;

  // Créer le renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.value.clientWidth, container.value.clientHeight);
  container.value.appendChild(renderer.domElement);

  // Ajouter les contrôles pour pouvoir naviguer avec la souris
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.rotateSpeed = 0.5;
  controls.zoomSpeed = 0.7;
  controls.minDistance = 3;
  controls.maxDistance = 15;
  controls.update();

  // Charger la texture de la Terre
  const earthTexture = textureLoader.load('/textures/earth.jpg');
  const earthBumpMap = textureLoader.load('/textures/earth_normal.jpg');
  
  // Créer le soleil en premier pour pouvoir utiliser sa position dans les shaders
  const sunGeometry = new THREE.SphereGeometry(5, 64, 64);
  const sunTexture = textureLoader.load('/textures/space/sun.jpg');
  
  // Matériau pour le soleil avec émission de lumière - utiliser MeshStandardMaterial avec emissive
  const sunMaterial = new THREE.MeshStandardMaterial({
    map: sunTexture,
    color: 0xffdd66,
    emissive: 0xffdd66,
    emissiveIntensity: 1.0,
    roughness: 0.1,
    metalness: 0.0
  });
  
  const sun = new THREE.Mesh(sunGeometry, sunMaterial);
  // Positionner le soleil plus près pour un meilleur éclairage
  sun.position.set(10, 5, 10);
  scene.add(sun);
  
  // Création d'une texture de relief plus accentuée pour les montagnes
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 512;
  const context = canvas.getContext('2d');
  
  // Charger l'image de bump map pour la traiter
  const bumpImage = new Image();
  bumpImage.src = '/textures/earth_normal.jpg';
  bumpImage.onload = () => {
    // Dessiner l'image sur le canvas
    context.drawImage(bumpImage, 0, 0, canvas.width, canvas.height);
    
    // Récupérer les données de l'image
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Augmenter beaucoup plus le contraste pour accentuer fortement le relief
    for (let i = 0; i < data.length; i += 4) {
      // Calculer la luminosité (moyenne simple des composantes RGB)
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      
      // Appliquer un contraste beaucoup plus fort aux zones montagneuses (valeurs élevées)
      if (avg > 128) {
        // Valeurs plus élevées pour les points lumineux (montagnes)
        data[i] = Math.min(255, avg * 2.0);     // R
        data[i + 1] = Math.min(255, avg * 2.0); // G
        data[i + 2] = Math.min(255, avg * 2.0); // B
      } else {
        // Valeurs plus basses pour les vallées
        data[i] = Math.max(0, avg * 0.5);     // R
        data[i + 1] = Math.max(0, avg * 0.5); // G
        data[i + 2] = Math.max(0, avg * 0.5); // B
      }
    }
    
    // Appliquer les modifications
    context.putImageData(imageData, 0, 0);
    
    // Créer une texture à partir du canvas
    const enhancedBumpMap = new THREE.CanvasTexture(canvas);
  };
  
  // Créer la Terre
  const earthGeometry = new THREE.SphereGeometry(2, 192, 192);
  
  // S'assurer que les textures sont chargées avant d'initialiser le shader
  const loadedTextures = {
    earth: false,
    earthBump: false
  };
  
  // Créons un matériau temporaire simple pour la Terre en attendant que les textures soient chargées
  const tempEarthMaterial = new THREE.MeshBasicMaterial({ color: 0x2233aa });
  earth = new THREE.Mesh(earthGeometry, tempEarthMaterial);
  scene.add(earth);
  
  // Ajouter une légère inclinaison comme l'axe terrestre réel
  earth.rotation.x = Math.PI * 0.1;
  
  // Réinitialiser les textures avec des callbacks pour s'assurer qu'elles sont chargées
  textureLoader.load('/textures/earth.jpg', (texture) => {
    loadedTextures.earth = true;
    createEarthShader(texture, earthBumpMap);
  });
  
  textureLoader.load('/textures/earth_normal.jpg', (texture) => {
    loadedTextures.earthBump = true;
    createEarthShader(earthTexture, texture);
  });
  
  // Fonction pour créer le shader de la Terre une fois les textures chargées
  let earthShaderMaterial;
  function createEarthShader(dayTex, bumpTex) {
    // Vérifier que les deux textures sont chargées
    if (!loadedTextures.earth || !loadedTextures.earthBump) return;
    
    // Créer un matériau plus avancé avec des propriétés améliorées
    const earthMaterial = new THREE.MeshStandardMaterial({
      map: dayTex,
      bumpMap: bumpTex,
      bumpScale: 0.8,               // Augmenter l'échelle du bump pour plus de relief
      normalMap: bumpTex,
      normalScale: new THREE.Vector2(1.5, 1.5),  // Augmenter l'échelle des normales
      roughness: 0.55,              // Rugosité modérée
      metalness: 0.05,              // Légèrement métallique pour les reflets
      emissive: new THREE.Color(0x112233),  // Couleur bleutée pour le côté nuit
      emissiveIntensity: 0.1,       // Faible intensité pour le côté nuit
      color: 0xffffff,
      displacementMap: bumpTex,
      displacementScale: 0.25,      // Déplacement modéré pour le relief
      displacementBias: -0.125,     // Ajustement du déplacement
    });
    
    // Appliquer le matériau à la Terre
    earth.material = earthMaterial;
    
    // Activer les ombres
    earth.castShadow = true;
    earth.receiveShadow = true;
  }
  
  // Ajouter la Terre à la scène
  scene.add(earth);
  
  // Ajouter un effet de lueur autour du soleil (glow)
  const sunGlowGeometry = new THREE.SphereGeometry(5.5, 32, 32);
  const sunGlowMaterial = new THREE.ShaderMaterial({
    uniforms: {
      "c": { value: 0.2 },
      "p": { value: 5.5 },
      glowColor: { value: new THREE.Color(0xffee66) },
      viewVector: { value: new THREE.Vector3() }
    },
    vertexShader: `
      uniform vec3 viewVector;
      uniform float c;
      uniform float p;
      varying float intensity;
      void main() {
        vec3 vNormal = normalize(normal);
        vec3 vNormel = normalize(viewVector);
        intensity = pow(c - dot(vNormal, vNormel), p);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 glowColor;
      varying float intensity;
      void main() {
        gl_FragColor = vec4(glowColor, intensity);
      }
    `,
    side: THREE.BackSide,
    blending: THREE.AdditiveBlending,
    transparent: true
  });
  
  const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
  sunGlow.position.copy(sun.position);
  scene.add(sunGlow);
  
  // Créer une source de lumière au niveau du soleil
  const sunLight = new THREE.PointLight(0xffeebb, 10.0, 100, 1.5);
  sunLight.position.copy(sun.position);
  
  // Améliorer les ombres du soleil
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.bias = -0.001;
  sunLight.shadow.radius = 2;
  
  scene.add(sunLight);
  
  // Configurer le renderer pour gérer les ombres
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  // Faire en sorte que la Terre reçoive des ombres
  earth.receiveShadow = true;
  
  // Ajouter des effets de lentille au soleil
  const textureFlare0 = textureLoader.load('/textures/space/lensflare0.png');
  const textureFlare1 = textureLoader.load('/textures/space/lensflare1.png');
  const textureFlare2 = textureLoader.load('/textures/space/lensflare2.png');
  
  const lensflare = new Lensflare();
  lensflare.addElement(new LensflareElement(textureFlare0, 700, 0, sunLight.color));
  lensflare.addElement(new LensflareElement(textureFlare1, 70, 0.6));
  lensflare.addElement(new LensflareElement(textureFlare2, 170, 0.7));
  lensflare.addElement(new LensflareElement(textureFlare2, 120, 0.9));
  lensflare.addElement(new LensflareElement(textureFlare2, 70, 1.0));
  sunLight.add(lensflare);

  // Créer un shader personnalisé pour le soleil
  const sunShaderMaterial = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0.0 },
      color: { value: new THREE.Color(0xffdd66) },
      sunTexture: { value: sunTexture }
    },
    vertexShader: `
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform vec3 color;
      uniform sampler2D sunTexture;
      
      varying vec2 vUv;
      
      void main() {
        // Déformation des coordonnées UV pour simuler le mouvement du plasma
        vec2 distortedUV = vUv;
        distortedUV.x += sin(distortedUV.y * 10.0 + time * 0.5) * 0.01;
        distortedUV.y += cos(distortedUV.x * 10.0 + time * 0.5) * 0.01;
        
        vec4 texColor = texture2D(sunTexture, distortedUV);
        
        // Ajouter des éruptions solaires
        float flare = sin(vUv.y * 30.0 + time * 2.0) * sin(vUv.x * 30.0 + time * 2.0);
        flare = max(0.0, flare) * 0.5;
        
        // Couleur finale
        vec3 finalColor = texColor.rgb * color + flare * vec3(1.0, 0.6, 0.2);
        
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `,
    blending: THREE.AdditiveBlending
  });
  
  // Remplacer le matériau du soleil par le shader
  sun.material = sunShaderMaterial;

  // Créer le satellite
  const satelliteGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.1);
  const satelliteMaterial = new THREE.MeshStandardMaterial({
    color: 0xd4af37,
    metalness: 0.8,
    roughness: 0.2,
    emissive: 0x555555,
  });
  satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
  
  // Maintenant que le satellite est créé, on peut définir sa propriété castShadow
  satellite.castShadow = true;
  
  // Ajouter des panneaux solaires au satellite
  const panelGeometry = new THREE.BoxGeometry(0.6, 0.01, 0.2);
  const panelMaterial = new THREE.MeshStandardMaterial({
    color: 0x2222ff,
    metalness: 0.8,
    roughness: 0.2,
  });
  
  const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
  leftPanel.position.set(0, 0, 0.2);
  satellite.add(leftPanel);
  
  const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
  rightPanel.position.set(0, 0, -0.2);
  satellite.add(rightPanel);
  
  // Placer le satellite dans un groupe pour faciliter l'orbite
  const satelliteOrbit = new THREE.Group();
  satelliteOrbit.add(satellite);
  satellite.position.set(4, 0, 0); // Position initiale du satellite
  
  // Incliner légèrement l'orbite
  satelliteOrbit.rotation.x = Math.PI * 0.1;
  scene.add(satelliteOrbit);

  // Réduire l'intensité de la lumière ambiante pour avoir plus de contraste
  const ambientLight = new THREE.AmbientLight(0x404050, 0.3);
  scene.add(ambientLight);

  // Réduire l'intensité de la lumière hémisphérique
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x303050, 0.7);
  scene.add(hemiLight);

  // Ajouter un léger effet de scintillement aux étoiles
  const tweenSkybox = () => {
    const time = Date.now() * 0.0003;
    
    // Faire scintiller les étoiles
    starField.rotation.y += 0.0001;
    farStarField.rotation.y += 0.00005;
    
    // Animer légèrement l'opacité des étoiles pour un effet de scintillement
    starsMaterial.opacity = 0.6 + Math.sin(time) * 0.2;
    farStarsMaterial.opacity = 0.4 + Math.cos(time) * 0.15;
    
    // Une légère rotation du skybox pour donner un sentiment de mouvement
    skybox.rotation.y += 0.00005;
    innerSkybox.rotation.y -= 0.00007; // Rotation en sens inverse pour créer un effet parallaxe
    
    // Animer le soleil et sa lueur
    sun.rotation.y += 0.0003;
    
    // Mettre à jour le vecteur de vue pour l'effet de halo
    const camVec = new THREE.Vector3();
    camVec.subVectors(camera.position, sunGlow.position).normalize();
    sunGlowMaterial.uniforms.viewVector.value = camVec;
    
    // Animation du halo du soleil (pulsation) - corriger l'échelle
    const glowFactor = 0.1 + Math.sin(time * 2) * 0.05;
    sunGlow.scale.set(1 + glowFactor, 1 + glowFactor, 1 + glowFactor);
    
    setTimeout(tweenSkybox, 100);
  };
  tweenSkybox();

  // Animation
  function animate() {
    animationFrameId = requestAnimationFrame(animate);

    const currentTime = Date.now() * 0.001; // Temps en secondes
    
    // Rotation de la Terre (ralentie)
    earth.rotation.y += 0.0008;
    
    // Rotation du satellite autour de la Terre
    satelliteOrbit.rotation.y += 0.008;
    
    // Rotation du satellite sur lui-même
    satellite.rotation.y += 0.01;
    
    // Mettre à jour les shaders
    if (sunShaderMaterial && sunShaderMaterial.uniforms) {
      sunShaderMaterial.uniforms.time.value = currentTime;
    }
    
    controls.update();
    renderer.render(scene, camera);
  }

  animate();

  // Gérer le redimensionnement de la fenêtre
  window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
  if (!container.value) return;
  
  camera.aspect = container.value.clientWidth / container.value.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.value.clientWidth, container.value.clientHeight);
}

function cleanup() {
  window.removeEventListener('resize', onWindowResize);
  cancelAnimationFrame(animationFrameId);
  
  if (container.value && renderer) {
    container.value.removeChild(renderer.domElement);
  }
  
  // Libérer la mémoire
  if (scene) {
    scene.clear();
  }
}

onMounted(() => {
  init();
});

onBeforeUnmount(() => {
  cleanup();
});
</script>

<style scoped>
.earth-container {
  width: 100%;
  height: 100vh;
  display: block;
}
</style> 